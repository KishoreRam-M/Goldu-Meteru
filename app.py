# -*- coding: utf-8 -*-
"""Goldu-Meter

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dkiMJ2wEBtO0Whlpx4774xu14XqCnsF0

# IMPORT Lib
"""

import yfinance as yf
import pandas as pd
import numpy as np
from datetime import date, timedelta
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import GRU, Dense, Dropout, Input
from tensorflow.keras.callbacks import EarlyStopping

import matplotlib.pyplot as plt
import gradio as gr
import warnings

warnings.filterwarnings('ignore')

tf.random.set_seed(42)
np.random.seed(42)

print("Fetching 5 years of historical data...")

end_date = date.today()
start_date = end_date - timedelta(days=5 * 365)

symbols = {
    "Gold": "GC=F",
    "USD_Index": "DX-Y.NYB",
    "Crude_Oil": "CL=F",
    "US10Y_Yield": "^TNX",
    "SP500": "^GSPC",
    "Nifty50": "^NSEI",
    "USDINR": "INR=X",
    "Gold_ETF_GLD": "GLD",
    "VIX": "^VIX"
}

data = pd.DataFrame()
for name, symbol in symbols.items():
    try:
        df = yf.download(symbol, start=start_date, end=end_date, progress=False)[["Close"]]
        df = df.rename(columns={"Close": name})
        data = pd.concat([data, df], axis=1)
    except Exception as e:
        print(f"‚ö†Ô∏è Failed to fetch {name}: {e}")

data = data.ffill()
print(" Data fetching complete.")

print(" Engineering time-series features...")

data['Gold_Target_Diff'] = data['Gold'].diff(1)
data['Gold_Lag_1'] = data['Gold'].shift(1)
data['Gold_MA_10'] = data['Gold'].shift(1).rolling(window=10).mean()
data['Gold_MA_50'] = data['Gold'].shift(1).rolling(window=50).mean()
data['Gold_ROC_1'] = data['Gold'].pct_change(1).shift(1)
data['Gold_Volatility_10'] = data['Gold'].shift(1).rolling(window=10).std()

for col in ["Crude_Oil", "SP500", "USD_Index", "US10Y_Yield", "Nifty50", "USDINR", "Gold_ETF_GLD", "VIX"]:
    data[f"{col}_Lag_1"] = data[col].shift(1)

original_rows = data.shape[0]
data = data.dropna()
print(f" Feature engineering complete. Dropped {original_rows - data.shape[0]} rows.")

print("Splitting, scaling, and creating sequences...")

features_to_drop = ["Gold", "Gold_Target_Diff", "USD_Index", "Crude_Oil",
                    "US10Y_Yield", "SP500", "Nifty50", "USDINR",
                    "Gold_ETF_GLD", "VIX"]
features_df = data.drop(columns=features_to_drop)
target_df = data["Gold_Target_Diff"]

feature_names = list(features_df.columns)
n_features = len(feature_names)

test_size = int(len(features_df) * 0.2)
train_features_df = features_df.iloc[:-test_size]
test_features_df = features_df.iloc[-test_size:]
train_target_df = target_df.iloc[:-test_size]
test_target_df = target_df.iloc[-test_size:]

scaler_X = MinMaxScaler()
scaler_y = MinMaxScaler()

X_train_scaled = scaler_X.fit_transform(train_features_df)
y_train_scaled = scaler_y.fit_transform(train_target_df.values.reshape(-1, 1))
X_test_scaled = scaler_X.transform(test_features_df)
y_test_scaled = scaler_y.transform(test_target_df.values.reshape(-1, 1))

def create_dataset(X, y, time_steps=1):
    Xs, ys = [], []
    for i in range(len(X) - time_steps):
        v = X[i:(i + time_steps)]
        Xs.append(v)
        ys.append(y[i + time_steps])
    return np.array(Xs), np.array(ys)

TIME_STEPS = 60
X_train_seq, y_train_seq = create_dataset(X_train_scaled, y_train_scaled, TIME_STEPS)
X_test_seq, y_test_seq = create_dataset(X_test_scaled, y_test_scaled, TIME_STEPS)

print(f" Data prepared. Train X: {X_train_seq.shape}, Test X: {X_test_seq.shape}")

print("Building GRU model...")

def build_gru_model(input_shape):
    model = Sequential([
        Input(shape=input_shape),
        GRU(100, return_sequences=True),
        Dropout(0.2),
        GRU(50),
        Dropout(0.2),
        Dense(25, activation='relu'),
        Dense(1)
    ])
    model.compile(optimizer='adam', loss='mean_squared_error')
    return model

model = build_gru_model((TIME_STEPS, n_features))
model.summary()

print("Training GRU model...")

early_stopping = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)

history = model.fit(
    X_train_seq, y_train_seq,
    epochs=100, batch_size=32,
    validation_data=(X_test_seq, y_test_seq),
    callbacks=[early_stopping],
    verbose=1,
    shuffle=False
)

print(" Model training complete.")

print("Evaluating model performance...")

y_pred_scaled = model.predict(X_test_seq)
y_pred_diff = scaler_y.inverse_transform(y_pred_scaled).flatten()
yesterdays_price = test_features_df['Gold_Lag_1'].values[TIME_STEPS:]
y_pred_real = yesterdays_price + y_pred_diff
y_test_real = data['Gold'].loc[test_target_df.index].values[TIME_STEPS:]

r2 = r2_score(y_test_real, y_pred_real)
mae = mean_absolute_error(y_test_real, y_pred_real)
rmse = np.sqrt(mean_squared_error(y_test_real, y_pred_real))

print(f"R¬≤: {r2:.4f}, MAE: {mae:.2f}, RMSE: {rmse:.2f}")

print("Generating visualizations...")

plt.figure(figsize=(14,7))
test_index = test_target_df.index[TIME_STEPS:]
plt.plot(test_index, y_test_real, label="Actual Gold (USD)", color='blue')
plt.plot(test_index, y_pred_real, label="Predicted Gold (USD)", color='orange', linestyle='--')
plt.legend(); plt.title(f"GRU Gold Prediction (R¬≤={r2:.4f})")
plt.tight_layout(); plt.savefig("goldu_prediction_plot.png"); plt.close()

plt.figure(figsize=(10,6))
plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.legend(); plt.title('Training vs Validation Loss')
plt.tight_layout(); plt.savefig("goldu_training_loss.png"); plt.close()

print(" Plots saved (goldu_prediction_plot.png, goldu_training_loss.png)")

print(" Building live prediction logic...")

ounce_to_gram = 31.1035
last_known_inr = 85.0

def get_live_usd_to_inr():
    global last_known_inr
    try:
        df = yf.download("INR=X", period="2d", interval="1h", progress=False)
        if not df.empty:
            last_known_inr = float(df["Close"].iloc[-1])
        return last_known_inr
    except:
        return last_known_inr

def get_prediction_input_data():
    fetch_end = date.today() + timedelta(days=1)
    fetch_start = fetch_end - timedelta(days=120)
    live_data = pd.DataFrame()
    for name, symbol in symbols.items():
        df = yf.download(symbol, start=fetch_start, end=fetch_end, progress=False)[["Close"]]
        df = df.rename(columns={"Close": name})
        live_data = pd.concat([live_data, df], axis=1)
    live_data = live_data.ffill()
    for col in ["Gold_Lag_1","Gold_MA_10","Gold_MA_50","Gold_ROC_1","Gold_Volatility_10"]:
        live_data[col] = np.nan
    live_data['Gold_Lag_1'] = live_data['Gold'].shift(1)
    live_data['Gold_MA_10'] = live_data['Gold'].shift(1).rolling(window=10).mean()
    live_data['Gold_MA_50'] = live_data['Gold'].shift(1).rolling(window=50).mean()
    live_data['Gold_ROC_1'] = live_data['Gold'].pct_change(1).shift(1)
    live_data['Gold_Volatility_10'] = live_data['Gold'].shift(1).rolling(window=10).std()
    for col in ["Crude_Oil","SP500","USD_Index","US10Y_Yield","Nifty50","USDINR","Gold_ETF_GLD","VIX"]:
        live_data[f"{col}_Lag_1"] = live_data[col].shift(1)
    live_data_features = live_data[feature_names].iloc[-TIME_STEPS:]
    live_data_features = live_data_features.fillna(method='ffill').fillna(0)
    return live_data_features, live_data['Gold'].iloc[-1], live_data.index[-1]

def predict_gold_price():
    usd_to_inr = get_live_usd_to_inr()
    new_X, last_price, date_ref = get_prediction_input_data()
    new_X_scaled = scaler_X.transform(new_X)
    new_X_seq = np.reshape(new_X_scaled, (1, TIME_STEPS, n_features))
    pred_scaled = model.predict(new_X_seq)
    pred_diff = scaler_y.inverse_transform(pred_scaled)
    pred_usd = float(last_price) + float(pred_diff[0][0])
    pred_inr_per_10_gram = (pred_usd * usd_to_inr / ounce_to_gram) * 10
    return (
        f"**Prediction for {date_ref.strftime('%Y-%m-%d')}**\n\n"
        f"üá∫üá∏ Predicted USD/Ounce: **${pred_usd:.2f}**\n"
        f"üáÆüá≥ Predicted INR/10g: **‚Çπ{pred_inr_per_10_gram:.2f}**"
    )

print(" Live prediction function built.")

import gradio as gr


print("Launching Gradio interface...")

# App description
description = f"""
# üíé Goldu Meter Pro üáÆüá≥
### (v5.0 - GRU Deep Learning Model)

Developed by: **Kishore Ram M**
_‚ÄúBorn in Tenkasi, built with Tamil spirit & tech passion.‚Äù_

**Model Performance:**
- R¬≤: {{r2:.4f}}
- MAE: ${{mae:.2f}}
- RMSE: ${{rmse:.2f}}
"""

# Profile and credits section (HTML)
profile_html = """
<div style="font-family: 'Poppins', sans-serif; text-align: center; padding: 20px;">
    <h2 style="color: #0078D7;">üë®‚Äçüíª Connect with Me</h2>
    <p>
        <a href="https://github.com/KishoreRam-M" target="_blank" style="text-decoration:none; color:#333; font-size:18px;">
            üß† GitHub
        </a> |
        <a href="https://www.linkedin.com/in/kishoreramm/" target="_blank" style="text-decoration:none; color:#0A66C2; font-size:18px;">
            üíº LinkedIn
        </a> |
        <a href="https://www.geeksforgeeks.org/user/kishorera8zln/" target="_blank" style="text-decoration:none; color:#0F9D58; font-size:18px;">
            üß© GeeksforGeeks
        </a> |
        <a href="https://zencoder-portfolio.vercel.app/" target="_blank" style="text-decoration:none; color:#A020F0; font-size:18px;">
            üåê Portfolio
        </a>
    </p>

    <p>
        üìß <a href="mailto:kishoreramm.dev@gmail.com" style="text-decoration:none; color:#D93025; font-size:18px;">
        kishoreramm.dev@gmail.com
        </a>
    </p>

    <p style="margin-top: 20px; font-size:14px; color:gray;">
        Made with ‚ù§Ô∏è by <b>Kishore Ram M</b> from <b>Tenkasi, Tamil Nadu</b><br>
        <i>‚ÄúCode crafted in Tamil Nadu, shining in global markets.‚Äù</i>
    </p>
</div>
"""

# Gradio Interface
with gr.Blocks(theme=gr.themes.Soft(), title="Goldu Meter Pro ‚Äî AI Gold Price Predictor") as iface:
    gr.Markdown(description)

    with gr.Row():
        predict_button = gr.Button("üîÆ Predict Next Day's Gold Price", variant="primary")

    output_markdown = gr.Markdown("Click the button above to get the AI-powered prediction...")

    predict_button.click(predict_gold_price, inputs=[], outputs=[output_markdown])

    gr.Image("goldu_prediction_plot.png", label="üìà Predicted Gold Price Trend")
    gr.Image("goldu_training_loss.png", label="üß† Model Training Loss Curve")

    gr.HTML(profile_html)

iface.launch()